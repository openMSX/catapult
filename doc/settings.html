<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<link title="Catapult doc style" rel="stylesheet" href="doc.css" type="text/css" />
<title>openMSX Catapult - Settings Framework</title>
</head>

<body>

<h1>openMSX Catapult - Settings Framework</h1>

<h2>Definition of Setting</h2>

<p>
openMSX uses settings for both persistent user preferences and non-persistent configuration items. A setting has the following properties:
</p>
<ul>
<li>name</li>
<li>type</li>
<li>current value</li>
<li>default value</li>
<li>range</li>
<li>persistent or not</li>
<li>help text</li>
</ul>
<p>
For some types (such as string) the range is always the full type: any string is possible. For ordered types (int, float) range is a minimum and maximum value. For enumerations, range is the list of possible values.
</p>
<p>
Both the current value and the range are dynamic. An example of a dynamic range is the "videosource" setting: if a GFX9000 cartridge is inserted, an additional video source becomes available.
</p>
<p>
Setting existence is also dynamic: for example sound settings such as volume and balance exist for each sound device and sound devices can come and go at runtime. Another example is the firmware setting, which is only available on machines that have indeed switchable firmware.
</p>

<h2>Requirements for Setting Support in Catapult</h2>

<p>
Much of the functionality of Catapult consists of controlling openMSX settings. Therefore, we want to have a framework that offers an easy way to observe and modify settings.
</p>
<p>
Here is an overview of how Catapult should handle the different setting properties:
</p>
<dl>
<dt>name</dt>
<dd>Settings are identified by their name. If a setting name changes, the Catapult code must be updated to match.</dd>
<dt>type</dt>
<dd>The setting type that Catapult expects must match the type of the setting in openMSX: a checkbox can represent a boolean setting, but not a string setting. If a setting type changes, the Catapult code must be updated to match.</dd>
<dt>current value</dt>
<dd>Catapult must support the current value changing at runtime.</dd>
<dt>default value</dt>
<dd>Catapult must support resetting a setting to its default value. However, this does not necessarily mean that Catapult has to know that default value.</dd>
<dt>range</dt>
<dd>Catapult must support the range changing at runtime.</dd>
<dt>persistent or not</dt>
<dd>Catapult does not have to know whether a setting is persistent.</dd>
<dt>help text</dt>
<dd>The openMSX help text for a setting can be used in Catapult, to avoid duplication of these texts in source code. The help texts do not change at runtime.</dd>
</dl>

<p>
Typically there is a widget or set of widgets to control a particular setting. The framework must offer a way to keep the value of a widget synchronized to the value of the setting in openMSX: the widget's value must get updated when the setting's value changes and vice versa. This mechanism must avoid oscillation that can happen because of the latency of the asynchronous communication channel with openMSX.
</p>
<p>
In addition to synchronizing the current value, there must be a mechanism to synchronize the current range. Also "revert to default value" must be easy to trigger by a widget.
</p>
<P>
Settings may stop or start to exist when a machine is changed. It must be possible for a widget to be connected to a certain setting in the current machine. When a switch from an old machine to a new machine occurs, the widget should automatically be synchronized (and stay synchronized) to the same setting in the new machine.
</p>

<h2>Design</h2>

<ul>
<li>it is probably a good idea to have python settings classes for each openMSX settings class. Interesting case: filename setting: can we use it to do something clever with a file dialog?</li>
<li>setting properties (both static and dynamic) are fetched from openMSX. Some through 'settinginfo' updates from openMSX</li>
<li>all communication is asynchronous, this means that some data is not available right after registration of a setting. The framework or caller should be able to cope with this in a clean manner</li>
<li>we should be able to handle the fact that different widget types have different signals (names and signatures) for 'value changed' and different methods to set a value (e.g. in a ComboBox for EnumSettings, you have to find the proper index and set that as current)</li>
<li>we should take into account that we have to convert types in our setting code. E.g. Slider widgets do not support floats. We have to convert to ints and back to floats for this. Other (small) conversions need to take place for booleans in checkboxes, e.g.</li>
</ul>

<p class="version">
$Id$
</p>

</body>
</html>
